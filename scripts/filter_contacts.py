# Quick script to filter-out unwanted contacts
import logging
import argparse
import multiprocessing
import os
import subprocess
import itertools

nsp7 = list(range(116, 196))
exosc4 = list(range(304, 537))
exosc2 = list(range(1747, 1996))
forbidden_contacts = list(itertools.product(*[nsp7, exosc2])) + list(itertools.product(*[nsp7, exosc4]))


def calculate_contact(contact_exe, pdb_file, cutoff=4.9):
    """Calculate all intermolecular contacts present in a PDB file in a given cutoff."""
    output_f = pdb_file.replace('.pdb', '.contacts')
    if not os.path.isfile(output_f):
        logging.debug('Calculating contacts in %s', pdb_file)
        cmd = [contact_exe, pdb_file, f'{cutoff}']
        result = subprocess.run(cmd, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                universal_newlines=True)
        if not result.stdout:
            return False
        with open(output_f, 'w') as out_fh:
            out_fh.write(result.stdout)
    return output_f


def load_contacts(rundir):
    """Parse multiple contact files and load them into a dictionary {PDB: (contacts)}."""
    logging.info('Reading contact files into internal data structure')
    contacts = {}
    with open(f'{rundir}/structures/it0/file.nam', 'r') as file_h:
        for line in file_h.readlines():
            pdb = line[:-1]
            contacts[pdb] = []
            contact_file = f"{rundir}/structures/it0/{pdb.replace('.pdb','.contacts')}"
            if not os.path.isfile(contact_file):
                logging.warning('No contact file for %s', pdb)
            else:
                with open(contact_file, 'r') as con_fh:
                    for line in con_fh.readlines():
                        data = line.split()
                        resnum_i = int(data[0])
                        resnum_j = int(data[3])
                        pair = resnum_i, resnum_j
                        if pair not in contacts[pdb]:
                            contacts[pdb].append(pair)
    return contacts


def filter_contacts(contact_d, forbidden_contacts, cutoff):
    """Filter the contacts by checking if any of the observed are present in the forbidden list."""
    logging.info('Filtering contacts, total forbidden contacts=%i forbidden contacts cutoff=%.2f', len(forbidden_contacts), cutoff)
    allowed_pdbs = []
    for pdb in contact_d:
        pdb_contacts = contact_d[pdb]
        if not pdb_contacts:
            continue
        total_pdb_contacts = len(pdb_contacts)
        intersection = len(set(pdb_contacts).intersection(forbidden_contacts))

        per_forbidden = intersection / total_pdb_contacts

        if per_forbidden <= cutoff:
            allowed_pdbs.append(pdb)
        else:
            logging.info('Structure %s discarded (%.2f)', pdb, per_forbidden)
    
    return allowed_pdbs


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("run_directory", help='file.nam generated by HADDOCK')
    parser.add_argument("contact_exec", help='Compiled contact script')
    parser.add_argument("--np", help='Number of processors to use', type=int, default=2)
    parser.add_argument("--cutoff", help='Cutoff of forbidden contacts allowed in the PDB to be filtered, float between 0 and 1', type=float, default=.2)
    args = parser.parse_args()

    logging.basicConfig(level='DEBUG',
                        format='%(asctime)s L%(lineno)d %(levelname)s - %(message)s',
                        datefmt='%d/%m/%Y %H:%M:%S')

    # Load the PDBs, note that here we are using it0 models
    logging.info('Loading PDB list from run directory %s', args.run_directory)
    pdb_list = []
    with open(f'{args.run_directory}/structures/it0/file.nam', 'r') as fh:
        for line in fh.readlines():
            pdb_list.append(line)

    # Use the contact script from haddock-tools to calculate contacts
    #  this is implemented using multiprocessors since this task can take a long time
    #  if there are too many PDBs, also because its embarassingly parallel so we might as well!
    # If a contact file is already present, the function will not re-calculate it so no time is
    #  wasted if you need to re-run this
    logging.info('Calculating contacts for %i PDBs using %i processors', len(pdb_list), args.np)
    pool = multiprocessing.Pool(processes=args.np)  # no logging inside the pool because its way to complicated
    for pdb in pdb_list:
        pdb_name = pdb[:-1]  # remove \n
        full_pdbname = f'{args.run_directory}/structures/it0/{pdb_name}'
        pool.apply_async(calculate_contact, args=(args.contact_exec, full_pdbname,))
    pool.close()
    pool.join()

    # Load the contacts in a dictionary
    observed_contacts = load_contacts(args.run_directory)

    # Finally do the filtering
    filtered_pdbs = filter_contacts(observed_contacts, forbidden_contacts, args.cutoff)
    
    # output to a text file
    logging.info('Writing filtered pdbs to filtered-pdbs.list')
    with open('filtered-pdbs.list', 'w') as out_fh:
        for pdb in filtered_pdbs:
            out_fh.write(f'{args.run_directory}/structures/it0/{pdb}\n')
    out_fh.close()

    # done
